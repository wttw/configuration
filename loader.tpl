// Code generated by "{{ .Command }}"; DO NOT EDIT.

package {{ .Package }}

import (
   {{- range .Imports}}
       {{ with .Name }}{{ . }} {{ end }}"{{ .Path }}"{{ end }}
)

{{ range .Fields }}
    {{ if ne .Strategy "Native" }}
        // wrapper type for {{ .Name }} {{ .TypeName }}
        {{ if .TypeElement }}
            type value{{ .Name }} struct {
                value *[]{{ .TypeElement }}
                changed bool
                }

                func (x *value{{ .Name }}) Set(s string) error {
            ss := strings.Split(s, ",")
            out := make([]{{ .TypeElement }}, len(ss))
                for i, d := range ss {
                    var err error
                {{ if eq .Strategy "Set" }}
                    err = out[i].Set(d)
                {{ else if eq .Strategy "Enumer" }}
                    out[i], err = {{.TypeName}}String(s)
                {{ else }}
                    {{ fail (printf "unhandled strategy [%s]" .Strategy) }}
                {{ end }}
                    if err != nil {
                        return err
                    }
                }
                if !x.changed {
                    *x.value = out
                    x.changed = true
                } else {
                    *x.value = append(*x.value, out...)
                }
                    return nil
                }

                func (x *value{{ .Name }}) String() string {
                return ""
                }

                func (x *value{{ .Name }}) Type() string {
                    return "{{ .TypeName }}"
                }
            {{ else }}
        type value{{ .Name }} {{ .TypeName }}

        func (x *value{{ .Name }}) Set(s string) error {
            {{ if eq .Strategy "Set" }}
                var v {{.TypeName}}
                    err := v.Set(s)
                    if err == nil {
                      *x = value{{.Name}}(v)
                    }
                return err
            {{ else if eq .Strategy "Enumer" }}
                v, err := {{.TypeName}}String(s)
                *x = value{{.Name}}(v)
                    return err
            {{ else }}
                {{ fail (printf "unhandled strategy [%s]" .Strategy) }}
            {{ end }}
        }

        func (x value{{ .Name }}) String() string {
            return ""
        }

        func (x value{{ .Name }}) Type() string {
        return "{{ .TypeName }}"
        }

            {{ end }}
    {{ end }}
{{ end }}

func (c *{{ .ConfigStruct }}) Load(args []string, flagset *{{ .Pflag }}.FlagSet, env map[string]string) {
  {{ range .Fields }}
      // {{ .Name }} {{ .TypeName }}
      {{ if eq .Strategy "Native" }}flagset.{{ .NativeFn }}(&c.{{ .Name }}, "{{ .FlagName }}", c.{{ .Name }}, `{{ .Description }}`)
      {{ else }}
          {{ if .TypeElement }}
              // whatev
              {{ else }}
          flagset.Var((*value{{ .Name }})(&c.{{ .Name }}), "{{ .FlagName }}", `{{ .Description }}`)
              {{ end }}
      {{ end }}
      {{ if .Hidden }}flagset.Lookup("{{ .FlagName }}").MarkHidden(true){{ end }}
              {{ if .EnvName }}if v, ok := env["{{ .EnvName }}"]; ok {
                  flagset.Set("{{ .Name }}", v)
                  }{{ end }}

  {{ end }}
}

func (c *{{ .ConfigStruct }}) Start() {
    flagset := {{ .Pflag }}.NewFlagSet(os.Args[0], {{ .Pflag }}.ExitOnError)
    env := map[string]string{}
    for _, v := range os.Environ() {
        equals := strings.IndexByte(v, '=')
        if equals != -1 {
            env[v[:equals]] = v[equals+1:]
        }
    }
    c.Load(os.Args[1:], flagset, env)
}